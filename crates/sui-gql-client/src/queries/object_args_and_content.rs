use af_sui_types::{ObjectArg, ObjectId, Version};
use futures::TryStreamExt as _;
use itertools::Itertools as _;
use sui_gql_schema::{scalars, schema};

use super::fragments::{MoveObjectContent, MoveValueRaw};
use super::object_args::{ObjectOwner, build_oarg_set_mut};
use super::objects_flat;
use super::objects_flat::Variables;
use crate::queries::fragments::ObjectFilterV2;
use crate::queries::outputs::RawMoveStruct;
use crate::{GraphQlClient, GraphQlErrors, GraphQlResponseExt as _};

type Query = objects_flat::Query<Object>;

// WARN: can't call this `Result`, otherwise it will messed with the code generated by the derive
// macros in this module.
type Res<T, C> = std::result::Result<T, Error<<C as GraphQlClient>::Error>>;

#[derive(thiserror::Error, Debug)]
pub enum Error<T> {
    #[error(transparent)]
    Client(T),
    #[error(transparent)]
    Server(#[from] GraphQlErrors),
    #[error("No data in object args query response")]
    NoData,
    #[error("Missing data for object: {0}")]
    MissingObject(ObjectId),
}

/// Get a sequence of object args and contents corresponding to `object_ids`, but not
/// necessarily in the same order.
///
/// The `mutable` argument controls whether we want to create mutable [`ObjectArg`]s, if they
/// are of the [`ObjectArg::SharedObject`] variant.
///
/// Fails if any object in the response is missing data.
pub async fn query<C: GraphQlClient>(
    client: &C,
    object_ids: impl IntoIterator<Item = ObjectId> + Send,
    mutable: bool,
    page_size: Option<u32>,
) -> Result<Vec<(ObjectArg, RawMoveStruct)>, Error<C::Error>> {
    let object_ids = object_ids.into_iter().collect_vec();
    let filter = ObjectFilterV2 {
        object_ids: Some(&object_ids),
        type_: None,
        owner: None,
    };
    let vars = Variables {
        filter: Some(filter),
        after: None,
        first: page_size.map(|n| n as i32),
    };

    let mut stream = std::pin::pin!(super::stream::forward(client, vars, request));

    let mut result = vec![];
    while let Some(Object {
        object_id,
        version,
        digest,
        owner,
        as_move_object,
    }) = stream.try_next().await?
    {
        let oarg = build_oarg_set_mut(object_id, version, owner, digest, mutable)
            .ok_or_else(|| Error::MissingObject(object_id))?;
        let content = as_move_object
            .and_then(|c| c.into_content())
            .ok_or_else(|| Error::MissingObject(object_id))?
            .try_into()
            .expect("Only Move structs can be top-level objects");
        result.push((oarg, content));
    }

    Ok(result)
}

async fn request<C: GraphQlClient>(
    client: &C,
    vars: Variables<'_>,
) -> Res<super::stream::Page<impl Iterator<Item = Res<Object, C>> + 'static + use<C>>, C> {
    let objects = client
        .query::<Query, _>(vars)
        .await
        .map_err(Error::Client)?
        .try_into_data()?
        .ok_or(Error::NoData)?
        .objects;

    Ok(super::stream::Page {
        info: objects.page_info.into(),
        data: objects.nodes.into_iter().map(Ok),
    })
}

#[cfg(test)]
#[allow(clippy::unwrap_used)]
#[test]
fn gql_output() {
    use cynic::QueryBuilder as _;
    let vars = Variables {
        filter: None,
        first: None,
        after: None,
    };
    let operation = Query::build(vars);
    insta::assert_snapshot!(operation.query, @r###"
    query Query($filter: ObjectFilter, $after: String, $first: Int) {
      objects(filter: $filter, first: $first, after: $after) {
        nodes {
          address
          version
          digest
          owner {
            __typename
            ... on Immutable {
              _
            }
            ... on Shared {
              __typename
              initialSharedVersion
            }
            ... on Parent {
              __typename
            }
            ... on AddressOwner {
              __typename
            }
          }
          asMoveObject {
            contents {
              type {
                repr
              }
              bcs
            }
          }
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
    "###);
}

// =============================================================================
//  Inner query fragments
// =============================================================================

#[derive(cynic::QueryFragment, Debug)]
struct Object {
    #[cynic(rename = "address")]
    object_id: ObjectId,
    version: Version,
    digest: Option<scalars::Digest>,
    owner: Option<ObjectOwner>,
    as_move_object: Option<MoveObjectContent<MoveValueRaw>>,
}
